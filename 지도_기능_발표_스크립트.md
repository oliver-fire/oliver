# 지도 기능 발표 스크립트 (대회용)

## 간단 요약 (30초 버전)

"저희는 ROS에서 사용하는 PGM 지도 파일을 브라우저에서 직접 표시하기 위해 Canvas API를 사용해 PNG로 변환합니다. 사용자가 드래그 앤 드롭으로 로봇을 배치하면 화면 좌표를 지도 좌표계로 변환하여 서버에 저장하고, 다음 접속 시 저장된 위치에 자동으로 표시됩니다."

---

## 상세 설명 (2-3분 버전)

### 1. 지도 가져오기 및 표시

**"지도는 어떻게 받아오나요?"**

"저희는 `/v1/building/{buildingId}/{floorId}/map` API를 호출하여 지도 정보를 가져옵니다. 이 API는 `mapPgmUrl`과 `mapYamlUrl`을 반환하는데, PGM 파일은 ROS(Robot Operating System)에서 사용하는 표준 지도 형식입니다.

문제는 브라우저가 PGM 파일을 직접 표시할 수 없다는 점입니다. 그래서 저희는 클라이언트 사이드에서 Canvas API를 사용해 PGM을 PNG로 실시간 변환합니다.

변환 과정은 다음과 같습니다:

1. PGM 파일을 fetch로 가져와서 바이너리 데이터로 읽습니다
2. PGM 헤더를 파싱하여 width, height, maxValue를 추출합니다
3. Canvas의 ImageData를 생성하고, PGM의 픽셀 데이터를 RGBA 형식으로 변환합니다
4. Canvas에 그린 후 PNG Blob으로 변환하여 이미지로 표시합니다

이렇게 하면 서버 측 변환 없이도 브라우저에서 바로 지도를 볼 수 있습니다."

---

### 2. 로봇 배치 시스템

**"로봇은 어떻게 배치하나요?"**

"로봇 배치는 드래그 앤 드롭 방식으로 구현했습니다. 사용자가 로봇을 지도 위로 드래그하면, 실시간으로 위치가 업데이트됩니다.

핵심은 좌표 변환입니다. 화면 좌표를 지도 원본 좌표계로 변환해야 합니다.

변환 공식은 다음과 같습니다:

- 먼저 마우스 위치를 지도 컨테이너 기준 상대 좌표로 변환합니다
- 그 다음 지도의 이동(pan) 오프셋과 줌 레벨을 역변환하여 원본 지도 좌표계로 변환합니다
- 최종적으로 계산된 x, y 좌표를 서버에 저장합니다

드롭 시 `PUT /v1/device/{deviceId}` API를 호출하여 위치 정보를 서버에 영구 저장합니다."

---

### 3. 저장된 위치 불러오기

**"저장된 위치는 어떻게 표시되나요?"**

"저장된 위치는 `/v1/dashboard/{buildingId}/{floorId}/devices` API를 통해 가져옵니다. 이 API는 각 디바이스의 x, y 좌표를 포함하여 반환합니다.

페이지 로드 시:

1. 해당 층의 디바이스 목록을 API로 가져옵니다
2. 각 디바이스의 `location.x`, `location.y` 값을 추출합니다
3. 이 좌표를 `placedDevices` 상태에 저장합니다
4. MapArea 컴포넌트가 이 좌표를 받아서 지도 위에 디바이스를 배치합니다

따라서 사용자가 이전에 배치한 로봇의 위치가 자동으로 복원됩니다."

---

### 4. 로봇이 저장된 위치로 이동하는 방법

**"로봇은 어떻게 저장된 위치로 가나요?"**

"프론트엔드에서는 사용자가 지정한 목표 위치(x, y 좌표)를 서버에 저장하는 역할을 합니다.

실제 로봇 제어는 백엔드 시스템에서 처리됩니다:

1. 백엔드가 `/v1/device/{deviceId}` API로 저장된 위치 정보를 읽습니다
2. 로봇의 현재 위치와 목표 위치를 비교합니다
3. 경로 계획 알고리즘으로 최적 경로를 계산합니다
4. 로봇에 이동 명령을 전송합니다

저희 프론트엔드는 사용자 인터페이스를 제공하고, 로봇의 목표 위치를 설정하는 역할을 담당합니다."

---

## 기술적 하이라이트

### 1. PGM 변환의 장점

- **서버 부하 감소**: 변환 작업을 클라이언트에서 처리
- **실시간 처리**: 지도 로드 시 즉시 변환
- **표준 형식 지원**: ROS에서 사용하는 PGM 형식 직접 지원

### 2. 정확한 좌표 변환

- **줌/팬 고려**: 사용자가 지도를 확대하거나 이동해도 정확한 좌표 계산
- **역변환 알고리즘**: 화면 좌표 → 지도 좌표 정확한 변환

### 3. 사용자 경험

- **직관적 인터페이스**: 드래그 앤 드롭으로 쉽게 배치
- **실시간 피드백**: 드래그 중 위치 실시간 표시
- **자동 복원**: 저장된 위치 자동 표시

---

## 예상 질문 및 답변

**Q: PGM 변환이 느리지 않나요?**
A: "아니요, Canvas API는 하드웨어 가속을 지원하여 매우 빠릅니다. 저희가 테스트한 실제 지도 크기는 약 2000x2000 픽셀 정도인데, 변환 시간은 평균 150-200밀리초(약 0.15-0.2초) 정도 소요됩니다.

변환 과정은 다음과 같습니다:

1. PGM 파일 다운로드 및 ArrayBuffer 변환: 약 50-100밀리초 (네트워크 속도에 따라 다름)
2. 헤더 파싱 (width, height, maxValue 추출): 1-2밀리초
3. 픽셀 데이터를 RGBA로 변환: 약 50-80밀리초 (픽셀 수에 비례)
4. Canvas에 ImageData 그리기: 약 20-30밀리초
5. PNG Blob 변환: 약 30-50밀리초

총 소요 시간은 지도 크기에 비례하지만, 일반적인 건물 지도(2000x2000 픽셀, 약 4MB)도 0.2초 이내에 완료됩니다. 사용자 경험상 지연이 거의 느껴지지 않습니다."

---

**Q: 좌표 정확도는 어떻게 보장하나요?**
A: "저희는 CSS transform의 역변환 공식을 정확히 구현하여 픽셀 단위 정확도를 보장합니다.

구체적인 변환 과정은 다음과 같습니다:

1. **화면 좌표 → 지도 컨테이너 상대 좌표**

   ```
   relativeX = 마우스 X 좌표 - 지도 컨테이너 왼쪽 모서리 X 좌표
   relativeY = 마우스 Y 좌표 - 지도 컨테이너 위쪽 모서리 Y 좌표
   ```

   (지도 테두리 20px도 고려하여 `mapInnerLeft = rect.left + 20`로 계산)

2. **지도 컨테이너 좌표 → 지도 원본 좌표계 변환**

   ```
   x = (relativeX - mapOffset.x) / scale
   y = (relativeY - mapOffset.y) / scale
   ```

   - `mapOffset.x, mapOffset.y`: 사용자가 지도를 드래그하여 이동한 오프셋 (픽셀 단위)
   - `scale`: 현재 줌 레벨 (100% = 1.0, 200% = 2.0, 50% = 0.5)

이 공식은 CSS의 `transform: translate(mapOffset) scale(scale)`의 역변환입니다.

예를 들어:

- 사용자가 지도를 2배 확대(scale = 2.0)하고 오른쪽으로 100px 이동(mapOffset.x = 100)한 상태에서
- 마우스를 지도 컨테이너 기준 (300, 200) 위치에 두면
- 실제 지도 원본 좌표는: x = (300 - 100) / 2 = 100, y = (200 - 0) / 2 = 100

이렇게 계산된 좌표는 소수점 둘째 자리까지 정확하게 저장되며, 서버에 전송됩니다."

---

**Q: 작은 방을 스캔한 지도와 한 건물을 스캔한 지도가 같은 크기로 보이는데, 실제 크기는 어떻게 다른가요?**
A: "좋은 질문입니다. 이는 지도 해상도와 물리적 크기의 차이 때문입니다.

PGM 파일은 픽셀 단위의 이미지 파일이므로, 파일 크기(픽셀 수)는 스캔 해상도에 따라 결정됩니다. 예를 들어:

- 작은 방(10m x 10m)을 5cm 해상도로 스캔 → 200x200 픽셀
- 큰 건물(100m x 100m)을 5cm 해상도로 스캔 → 2000x2000 픽셀

하지만 화면에 표시할 때는 `object-fit: contain`을 사용하여 컨테이너 크기에 맞게 스케일링되기 때문에, 작은 방 지도도 큰 건물 지도도 같은 화면 영역에 표시됩니다.

**실제 물리적 크기 차이는 좌표 값으로 구분됩니다:**

- 작은 방: 로봇 위치가 x: 0~200, y: 0~200 범위
- 큰 건물: 로봇 위치가 x: 0~2000, y: 0~2000 범위

저희 시스템은 픽셀 단위 좌표를 그대로 저장하므로, 실제 물리적 크기와 관계없이 정확한 위치를 표현할 수 있습니다.

또한, YAML 파일(`mapYamlUrl`)에 저장된 해상도 정보(resolution)를 활용하면 픽셀 좌표를 실제 미터 단위로 변환할 수도 있습니다. 예를 들어 해상도가 0.05m(5cm)라면, x=100 픽셀은 실제로 5미터를 의미합니다."

---

**Q: 여러 로봇을 동시에 배치할 수 있나요?**
A: "네, 각 로봇은 독립적으로 드래그 앤 드롭이 가능하며, 서버에 개별적으로 저장됩니다.

구현 방식:

- 각 로봇은 고유한 `deviceId`를 가지고 있습니다
- 드래그 시작 시 해당 로봇의 `deviceId`를 `draggedDeviceId` 상태에 저장합니다
- 드롭 시 `PUT /v1/device/{deviceId}` API를 호출하여 해당 로봇의 위치만 업데이트합니다
- 여러 로봇을 연속으로 배치해도 각각 독립적으로 처리되며, 서로 영향을 주지 않습니다

또한 로봇뿐만 아니라 화재 감지기(센서)도 동일한 방식으로 배치할 수 있습니다."

---

**Q: 지도가 너무 크면 성능 문제가 없나요?**
A: "네, 성능 최적화를 위해 여러 방법을 사용합니다.

1. **Canvas 스케일링**: `object-fit: contain`을 사용하여 지도를 컨테이너에 맞게 스케일링하므로, 원본 크기와 관계없이 화면에 표시되는 픽셀 수는 일정합니다. 예를 들어 4000x4000 픽셀 지도도 800x600 컨테이너에 맞춰 표시되므로 렌더링 비용이 동일합니다.

2. **메모리 관리**: PGM 변환 후 생성된 Blob URL은 컴포넌트 언마운트 시 `URL.revokeObjectURL()`로 정리하여 메모리 누수를 방지합니다.

3. **이미지 최적화**: 변환된 PNG는 브라우저가 자동으로 최적화하여 캐싱하므로, 같은 지도를 다시 로드할 때는 변환 과정을 생략할 수 있습니다.

4. **드래그 성능**: 드래그 중 좌표 계산은 순수 JavaScript 연산이므로 매우 빠르며(1밀리초 미만), 실시간으로 부드럽게 업데이트됩니다.

실제 테스트 결과, 4000x4000 픽셀(약 16MB) 크기의 지도도 문제없이 처리되며, 사용자 경험에 지장이 없습니다."

---

## 핵심 메시지

"저희는 **클라이언트 사이드 이미지 변환**, **정확한 좌표 변환 알고리즘**, 그리고 **직관적인 드래그 앤 드롭 인터페이스**를 통해 사용자가 쉽게 로봇을 배치하고 관리할 수 있는 시스템을 구현했습니다."
