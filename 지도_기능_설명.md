# 지도 기능 구현 설명서

## 1. 지도 이미지 가져오기 및 처리

### 1.1 API 호출

- **엔드포인트**: `GET /v1/building/{buildingId}/{floorId}/map`
- **응답 구조**:
  ```json
  {
    "status": 200,
    "message": "string",
    "responseAt": "2025-11-14T07:09:52.864Z",
    "data": {
      "buildingId": 1,
      "floorId": 1,
      "mapPgmUrl": "https://example.com/map.pgm",
      "mapYamlUrl": "https://example.com/map.yaml"
    }
  }
  ```

### 1.2 PGM 파일 처리

- **문제점**: PGM 파일은 브라우저에서 직접 표시할 수 없음
- **해결 방법**: 클라이언트 사이드에서 PGM을 PNG로 변환
- **변환 과정**:
  1. PGM 파일을 `fetch`로 가져와서 `ArrayBuffer`로 변환
  2. PGM 헤더 파싱 (매직 넘버 P2/P5, width, height, maxValue)
  3. Canvas API를 사용하여 ImageData 생성
  4. PGM 픽셀 데이터를 RGBA 형식으로 변환
  5. Canvas에 그린 후 `toBlob()`으로 PNG로 변환
  6. `URL.createObjectURL()`로 Blob URL 생성하여 이미지로 표시

### 1.3 지도 표시

- **컴포넌트**: `MapArea` (재사용 가능한 지도 컴포넌트)
- **기능**:
  - 줌 인/아웃 (마우스 휠, 50%~200%)
  - 지도 드래그 (pan)
  - 디바이스 표시 및 상호작용

---

## 2. 로봇 배치 시스템

### 2.1 드래그 앤 드롭 구현

- **드래그 시작**: 마우스 다운 이벤트에서 디바이스 선택
- **드래그 중**: 마우스 이동 이벤트로 실시간 위치 업데이트
- **좌표 변환**:
  ```
  화면 좌표 → 지도 컨테이너 상대 좌표 → 지도 원본 좌표계
  ```

  - 화면 좌표: `e.clientX, e.clientY`
  - 지도 컨테이너 기준: `relativeX = clientX - mapInnerLeft`
  - 지도 원본 좌표: `x = (relativeX - mapOffset.x) / scale`
  - `mapOffset`: 지도 이동 오프셋
  - `scale`: 줌 레벨 (100% = 1.0)

### 2.2 위치 저장

- **드롭 시**: 마우스 업 이벤트에서 최종 위치 계산
- **API 호출**: `PUT /v1/device/{deviceId}`
- **요청 본문**:
  ```json
  {
    "location": {
      "buildingId": "string",
      "floorId": "string",
      "x": 12.34,
      "y": 56.78
    }
  }
  ```
- **저장된 위치**: 서버의 데이터베이스에 영구 저장

---

## 3. 저장된 위치 불러오기 및 표시

### 3.1 디바이스 목록 가져오기

- **엔드포인트**: `GET /v1/dashboard/{buildingId}/{floorId}/devices`
- **응답 구조**:
  ```json
  {
    "status": 200,
    "message": "string",
    "responseAt": "2025-11-14T08:16:06.006Z",
    "data": [
      {
        "robotId": 1,
        "name": "Robot-001",
        "type": "robot",
        "status": "active",
        "location": {
          "x": 10.5,
          "y": 20.3
        }
      }
    ]
  }
  ```

### 3.2 초기 배치

- **과정**:
  1. 층 선택 시 `getDashboardFloorDevices` API 호출
  2. 응답의 `location.x`, `location.y` 추출
  3. `placedDevices` 상태에 저장
  4. `MapArea` 컴포넌트에 전달하여 지도에 표시

### 3.3 좌표 매핑

- **문제**: API 응답의 `robotId`와 실제 `deviceId`가 다를 수 있음
- **해결**: `getAllDevices` API로 전체 디바이스 목록을 가져와 이름과 타입으로 매핑
- **매핑 로직**: 이름과 타입이 일치하는 디바이스의 `deviceId`를 찾아서 사용

---

## 4. 로봇이 저장된 위치로 이동하는 방법

### 4.1 백엔드 처리 (추정)

- 로봇 제어 시스템이 `/v1/device/{deviceId}` API로 저장된 위치 정보를 읽음
- 로봇의 현재 위치와 목표 위치(x, y)를 비교
- 경로 계획 알고리즘으로 이동 경로 계산
- 로봇에 이동 명령 전송

### 4.2 프론트엔드 역할

- 사용자가 지도에서 로봇을 드래그하여 원하는 위치에 배치
- 드롭 시 서버에 x, y 좌표 저장
- 저장된 위치는 다음에 지도를 열 때 자동으로 표시됨

---

## 5. 기술 스택 및 주요 기술

### 5.1 사용 기술

- **프레임워크**: React + TypeScript
- **상태 관리**: React Hooks (useState, useEffect)
- **이미지 처리**: Canvas API
- **파일 형식**: PGM (Portable Gray Map) → PNG 변환
- **API 통신**: Axios 기반 API Client

### 5.2 핵심 알고리즘

- **좌표 변환**: 화면 좌표 ↔ 지도 좌표계 변환 (scale, offset 고려)
- **PGM 파싱**: Binary/ASCII PGM 형식 모두 지원
- **이미지 변환**: Canvas를 통한 실시간 이미지 포맷 변환

---

## 6. 사용자 플로우

1. **지도 로드**: 층 선택 → API 호출 → PGM 변환 → 지도 표시
2. **디바이스 표시**: API 호출 → x, y 좌표 추출 → 지도에 배치
3. **로봇 배치**: 드래그 → 좌표 계산 → 드롭 → 서버 저장
4. **위치 복원**: 다음 접속 시 저장된 x, y 좌표로 자동 배치

---

## 7. 주요 특징

- ✅ **실시간 좌표 변환**: 줌/팬 상태를 고려한 정확한 좌표 계산
- ✅ **PGM 지원**: ROS에서 사용하는 PGM 지도 형식 직접 지원
- ✅ **반응형 UI**: 드래그 앤 드롭으로 직관적인 로봇 배치
- ✅ **영구 저장**: 서버에 저장되어 다음 접속 시 자동 복원
- ✅ **다중 디바이스**: 로봇과 센서 모두 지원

